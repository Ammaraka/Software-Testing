<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VirtualReality: OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>OpenSim</b>      </li>
      <li><b>Region</b>      </li>
      <li><b>ScriptEngine</b>      </li>
      <li><b>Shared</b>      </li>
      <li><a class="el" href="../../d6/daa/namespaceOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog.html">YieldProlog</a>      </li>
      <li><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html">OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP" -->
<p><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html" title="YP has static methods for general functions in Yield Prolog such as getValue and unify.">YP</a> has static methods for general functions in Yield Prolog such as <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a63d52c4648e934ca25ae4d2ff08daafd" title="If value is a Variable, then return its getValue. Otherwise, just return value. You should call YP...">getValue</a> and <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aad2ab6a90418c116b00f5c867efacf54" title="If arg1 or arg2 is an object with a unify method (such as Variable or Functor) then just call its uni...">unify</a>.  
<a href="#_details">More...</a></p>

<p><a href="../../da/d7b/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc9/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1Catch.html">Catch</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumerator that wraps another enumerator in order to catch a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a>.  <a href="../../d8/dc9/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1Catch.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d1e/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1ClauseHeadAndBody.html">ClauseHeadAndBody</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="../../da/d1e/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1ClauseHeadAndBody.html" title="A ClauseHeadAndBody is used in Compiler.compileAnonymousFunction as a base class in order to implemen...">ClauseHeadAndBody</a> is used in Compiler.compileAnonymousFunction as a base class in order to implement <a class="el" href="../../df/dde/interfaceOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1IClause.html" title="An IClause is used so that dynamic predicates can call match.">YP.IClause</a>. After creating the object, you must call setHeadAndBody.  <a href="../../da/d1e/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1ClauseHeadAndBody.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dce/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1CodeListReader.html">CodeListReader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="../../db/dce/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1CodeListReader.html" title="CodeListReader extends TextReader and overrides Read to read the next code from the CodeList which is...">CodeListReader</a> extends TextReader and overrides Read to read the next code from the CodeList which is a Prolog list of integer character codes.  <a href="../../db/dce/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1CodeListReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Fail</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumerator that does zero loops. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interface &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dde/interfaceOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1IClause.html">IClause</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="../../df/dde/interfaceOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1IClause.html" title="An IClause is used so that dynamic predicates can call match.">IClause</a> is used so that dynamic predicates can call match.  <a href="../../df/dde/interfaceOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1IClause.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d5d/structOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1NameArity.html">NameArity</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is used for the lookup key in _factStore.  <a href="../../d5/d5d/structOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP_1_1NameArity.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Repeat</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumerator that repeats forever. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Succeed</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumerator that does one iteration. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a436feb8c6bdb64e68ec1e61fd9c00f16"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::abolish" ref="a436feb8c6bdb64e68ec1e61fd9c00f16" args="(object NameSlashArity)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>abolish</b> (object NameSlashArity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc66d9f2cd12602f262155c25beb767"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::abs" ref="a5bc66d9f2cd12602f262155c25beb767" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>abs</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5f7bb91f8900828a7f7eb125ba44de"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::add" ref="aca5f7bb91f8900828a7f7eb125ba44de" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>add</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae41e44af048d1dc71bd21b2150cd00b"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::addUniqueVariables" ref="aae41e44af048d1dc71bd21b2150cd00b" args="(object term, List&lt; Variable &gt; variableSet)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>addUniqueVariables</b> (object term, List&lt; <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html">Variable</a> &gt; variableSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1684a689c2baf50d7f3b94b431564c99"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::arg" ref="a1684a689c2baf50d7f3b94b431564c99" args="(object ArgNumber, object Term, object Value)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>arg</b> (object ArgNumber, object Term, object Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1f7cbfa88721625b2afe8e55abdf3e1"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::asserta" ref="ac1f7cbfa88721625b2afe8e55abdf3e1" args="(object Term, Type declaringClass)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>asserta</b> (object Term, Type declaringClass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab66d1fda848df7241fa592e3771e5183"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::assertDynamic" ref="ab66d1fda848df7241fa592e3771e5183" args="(object Term, Type declaringClass, bool prepend)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>assertDynamic</b> (object Term, Type declaringClass, bool prepend)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a0e5e5164736244adc482d6f7cba5d854">assertFact</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, object[] values)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert values at the end of the set of facts for the predicate with the name and with arity values.Length.  <a href="#a0e5e5164736244adc482d6f7cba5d854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3419d59e9c41003747ce33f4b407ef95"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::assertz" ref="a3419d59e9c41003747ce33f4b407ef95" args="(object Term, Type declaringClass)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>assertz</b> (object Term, Type declaringClass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4a185cb89f6618d32974dba0f9e147"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atan" ref="a9a4a185cb89f6618d32974dba0f9e147" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>atan</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aeaec716ad5415d797eed92f1a6009b"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atom" ref="a6aeaec716ad5415d797eed92f1a6009b" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6b3834333d1267f047a375bcf75c5a"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atom_chars" ref="a5b6b3834333d1267f047a375bcf75c5a" args="(object atom, object List)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_chars</b> (object atom, object List)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2edf2fce922dc20b4b6f683bc8dcb88"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atom_codes" ref="ad2edf2fce922dc20b4b6f683bc8dcb88" args="(object atom, object List)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_codes</b> (object atom, object List)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b8c1d4b32c783cabb18ee80fb566df"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atom_concat" ref="a15b8c1d4b32c783cabb18ee80fb566df" args="(object Start, object End, object Whole)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_concat</b> (object Start, object End, object Whole)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785c86dcab367830f6999440bc7f0b7c"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atom_length" ref="a785c86dcab367830f6999440bc7f0b7c" args="(object atom, object Length)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>atom_length</b> (object atom, object Length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ded59020dec662a932cdc1cbe83ffea"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::atomic" ref="a7ded59020dec662a932cdc1cbe83ffea" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>atomic</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45b782764e47f3aa9d2baae281fb6dd4"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::bitwiseAnd" ref="a45b782764e47f3aa9d2baae281fb6dd4" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>bitwiseAnd</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a3fa3e7ef12f8d3e5c1da9b98139d4"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::bitwiseComplement" ref="a66a3fa3e7ef12f8d3e5c1da9b98139d4" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>bitwiseComplement</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6f6ece8503e87662a047bf0dc3a952e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::bitwiseOr" ref="ae6f6ece8503e87662a047bf0dc3a952e" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>bitwiseOr</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab38b21d0eac208b11ed2786824c91949"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::bitwiseShiftLeft" ref="ab38b21d0eac208b11ed2786824c91949" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>bitwiseShiftLeft</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07deab75c9a6aec07fc3fd99b71696e5"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::bitwiseShiftRight" ref="a07deab75c9a6aec07fc3fd99b71696e5" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>bitwiseShiftRight</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a493bd708486bead5e6e911ac74d21711">ceiling</a> (object x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ISO standard returns an int.  <a href="#a493bd708486bead5e6e911ac74d21711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc8bf209a52d8b8923f63de0386fc6cd"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::char_code" ref="afc8bf209a52d8b8923f63de0386fc6cd" args="(object Char, object Code)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>char_code</b> (object Char, object Code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3292ae90208987355f10640a906243cb"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::clause" ref="a3292ae90208987355f10640a906243cb" args="(object Head, object Body)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>clause</b> (object Head, object Body)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60efff1dbabb5a0e3ab5ee03e0b9e294"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::compareTerms" ref="a60efff1dbabb5a0e3ab5ee03e0b9e294" args="(object Term1, object Term2)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compareTerms</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4e8ef942093cbe1e66bf6eee8c25a06"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::compound" ref="ae4e8ef942093cbe1e66bf6eee8c25a06" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>compound</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a955a2808f403700c18949347b96a47c4">convertDouble</a> (object term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert term to a double. This may convert an int to a double, etc. If term is a single-element List, use its first element (to handle the char types like "a"). If can't convert, throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for type_error evaluable (because this is only called from arithmetic functions).  <a href="#a955a2808f403700c18949347b96a47c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a34dbcfa4d9b3a2c2e2656eea4bc4029b">convertInt</a> (object term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert term to an int. If term is a single-element List, use its first element (to handle the char types like "a"). If can't convert, throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for type_error evaluable (because this is only called from arithmetic functions).  <a href="#a34dbcfa4d9b3a2c2e2656eea4bc4029b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4ef05ee15081b8c2fbe6c20038824d"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::copy_term" ref="abf4ef05ee15081b8c2fbe6c20038824d" args="(object inTerm, object outTerm)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>copy_term</b> (object inTerm, object outTerm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a476760fefd143c0502d62c15088842ff"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::cos" ref="a476760fefd143c0502d62c15088842ff" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>cos</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e6bee323fa7d087b99075ec28cab9a"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::current_input" ref="ab0e6bee323fa7d087b99075ec28cab9a" args="(object Stream)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>current_input</b> (object Stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff41365297c4787acaf77fa3568d3215"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::current_op" ref="aff41365297c4787acaf77fa3568d3215" args="(object Priority, object Specifier, object Operator)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>current_op</b> (object Priority, object Specifier, object Operator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ba761cd4787e0cdeb092eef5e50b3e2"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::current_output" ref="a3ba761cd4787e0cdeb092eef5e50b3e2" args="(object Stream)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>current_output</b> (object Stream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a5a14bf30491d3a19163f4316dce97a09">current_predicate</a> (object NameSlashArity, Type declaringClass)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If NameSlashArity is var, match with all the dynamic predicates using the Name/Artity form. If NameSlashArity is not var, check if the Name/Arity exists as a static or dynamic predicate.  <a href="#a5a14bf30491d3a19163f4316dce97a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c1ea83bb936bc7c438e7e69bc653aa"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::current_prolog_flag" ref="ac7c1ea83bb936bc7c438e7e69bc653aa" args="(object Key, object Value)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>current_prolog_flag</b> (object Key, object Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d0f596de6f96008037e574013619f2e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::cycComm" ref="a3d0f596de6f96008037e574013619f2e" args="(object msgobj)" -->
static string&nbsp;</td><td class="memItemRight" valign="bottom"><b>cycComm</b> (object msgobj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a740a42f3afe3de9b542675383ce5fa45">divide</a> (object x, object y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return floating point, even if both arguments are integer.  <a href="#a740a42f3afe3de9b542675383ce5fa45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ac9edd4afa9adee7d986b8901ead460"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::equal" ref="a6ac9edd4afa9adee7d986b8901ead460" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cbbf808c69baa9ab32fd52d66b09543"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::exp" ref="a7cbbf808c69baa9ab32fd52d66b09543" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>exp</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b10a4bda0c5ac54f24ef7d1d7cfff1e">fail</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.  <a href="#a7b10a4bda0c5ac54f24ef7d1d7cfff1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a61ac4eab31119bd86446e25a8bf29fed">floor</a> (object x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ISO standard returns an int.  <a href="#a61ac4eab31119bd86446e25a8bf29fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0ac1692b43a13511e72eececf754f9"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::functor" ref="aec0ac1692b43a13511e72eececf754f9" args="(object Term, object FunctorName, object Arity)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>functor</b> (object Term, object FunctorName, object Arity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cd822db9f470ed643421e468efaece1"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::get_code" ref="a6cd822db9f470ed643421e468efaece1" args="(object code)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_code</b> (object code)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#ad1f1d01cb281a94e5fc2eb71e49361a0">getFunctorArgs</a> (object term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If term is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or functor type, return an array of its args. Otherwise, return an empty array.  <a href="#ad1f1d01cb281a94e5fc2eb71e49361a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#ab205a11341384ec7c664d709e953aa6a">getFunctorName</a> (object term)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If term is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or functor type, return its name. Otherwise, return term.  <a href="#ab205a11341384ec7c664d709e953aa6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#afdb903ff06bf425a64689fa8b30c1818">getInt</a> (object term, out int intTerm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If term is an integer, set intTerm. If term is a single-element List, use its first element (to handle the char types like "a"). Return true for success, false if can't convert. We use a success return value because throwing an exception is inefficient.  <a href="#afdb903ff06bf425a64689fa8b30c1818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aa190a338167f3bb8f7f06ab26a9ff3cd">getIterator</a> (object Goal, Type declaringClass)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If Goal is a simple predicate, call YP.getFunctorName(Goal) using arguments from YP.getFunctorArgs(Goal). If not found, this throws a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for existence_error. Otherwise, compile the goal as a single clause predicate and invoke it.  <a href="#aa190a338167f3bb8f7f06ab26a9ff3cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a63d52c4648e934ca25ae4d2ff08daafd">getValue</a> (object value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If value is a <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a>, then return its getValue. Otherwise, just return value. You should call <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a63d52c4648e934ca25ae4d2ff08daafd" title="If value is a Variable, then return its getValue. Otherwise, just return value. You should call YP...">YP.getValue</a> on any object that may be a <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a> to get the value to pass to other functions in your system that are not part of Yield Prolog, such as math functions or file I/O. For more details, see <a href="http://yieldprolog.sourceforge.net/tutorial1.html.">http://yieldprolog.sourceforge.net/tutorial1.html.</a>  <a href="#a63d52c4648e934ca25ae4d2ff08daafd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30af63d6dd71a9ee9e7024fabdd93c16"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::greaterThan" ref="a30af63d6dd71a9ee9e7024fabdd93c16" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>greaterThan</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeae42303e266837530756676225070d5"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::greaterThanOrEqual" ref="aeae42303e266837530756676225070d5" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>greaterThanOrEqual</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb288ca474b486666435b7298a4bb42"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::ground" ref="a5eb288ca474b486666435b7298a4bb42" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>ground</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac4286c796cc0701af077eeb3e4a1776"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::intDivide" ref="aac4286c796cc0701af077eeb3e4a1776" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>intDivide</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7cccce34c34ace22ecfcb6badf19a29"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::integer" ref="af7cccce34c34ace22ecfcb6badf19a29" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>integer</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a651e941b5fb0c2c673c1a1825986d4ab">isDynamicCurrentPredicate</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, int arity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the dynamic predicate store has an entry for the predicate with name and arity.  <a href="#a651e941b5fb0c2c673c1a1825986d4ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e6e344cabf14b629c98e7f2d6ef10f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::isFloat" ref="ab1e6e344cabf14b629c98e7f2d6ef10f" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isFloat</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4194235714bc7ef41c49c114056f5682"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::lessThan" ref="a4194235714bc7ef41c49c114056f5682" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>lessThan</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab62ed27f88ac09fec40c3c4face48b6f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::lessThanOrEqual" ref="ab62ed27f88ac09fec40c3c4face48b6f" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>lessThanOrEqual</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa819fd873e59f1d229c78ee92b57f2c"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::log" ref="aaa819fd873e59f1d229c78ee92b57f2c" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>log</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22bca9ed0d450f9e609d00bf13c17f2e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::makeCopy" ref="a22bca9ed0d450f9e609d00bf13c17f2e" args="(object term, Variable.CopyStore copyStore)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>makeCopy</b> (object term, <a class="el" href="../../d8/d25/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable_1_1CopyStore.html">Variable.CopyStore</a> copyStore)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#af9822d343412e2ee20d27643769c4fd5">matchDynamic</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, object[] arguments)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match all clauses of the dynamic predicate with the name and with arity arguments.Length. If the predicate is not defined, return the result of <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a6c98742131aa7d2f4660423c044f5c21" title="If _prologFlags[&quot;unknown&quot;] is fail then return fail(), else if _prologFlags[&quot;unknown&q...">YP.unknownPredicate</a>.  <a href="#af9822d343412e2ee20d27643769c4fd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b476c556d99d02de9b5f6bf80e68367">matchFact</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, object[] arguments)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is deprecated and just calls matchDynamic. This matches all clauses, not just the ones defined with assertFact.  <a href="#a7b476c556d99d02de9b5f6bf80e68367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177e0cb29572d410a182d98b7cf20fa7"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::max" ref="a177e0cb29572d410a182d98b7cf20fa7" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>max</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bc845f57f999ae74b47a8fa48f5f44f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::min" ref="a4bc845f57f999ae74b47a8fa48f5f44f" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>min</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316b0c432522d0d1761f860e3b029961"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::mod" ref="a316b0c432522d0d1761f860e3b029961" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>mod</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d3c7a530351136a2adbb7d0048e37d"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::multiply" ref="ac1d3c7a530351136a2adbb7d0048e37d" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5df469f75e698c528396b846d50ef34"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::negate" ref="ab5df469f75e698c528396b846d50ef34" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>negate</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8205ce8dc5a76d6ab89955ac18077ce6"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::nl" ref="a8205ce8dc5a76d6ab89955ac18077ce6" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>nl</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f6e2ace031529cf5e1b8bd9ecca8c15"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::nonvar" ref="a7f6e2ace031529cf5e1b8bd9ecca8c15" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>nonvar</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e25ec88549e9ece0f19b598e95312a1"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::notEqual" ref="a6e25ec88549e9ece0f19b598e95312a1" args="(object x, object y)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>notEqual</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2c75ef031f1a369afc874d408db25f4"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::number" ref="ab2c75ef031f1a369afc874d408db25f4" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>number</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32fdcddc27ff3de6cb717e5905fd58fb"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::number_chars" ref="a32fdcddc27ff3de6cb717e5905fd58fb" args="(object Number, object List)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>number_chars</b> (object Number, object List)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31a2f6b39fc5e87706d582a58c7c3aef"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::number_codes" ref="a31a2f6b39fc5e87706d582a58c7c3aef" args="(object Number, object List)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>number_codes</b> (object Number, object List)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf2356616c369e37934ca133c3f3b2c6"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::pow" ref="abf2356616c369e37934ca133c3f3b2c6" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>pow</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a6d32f52e75d5d5f3b9c2f77ffa94a526">prependFact</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, object[] values)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert values, prepending to the front of the set of facts for the predicate with the name and with arity values.Length.  <a href="#a6d32f52e75d5d5f3b9c2f77ffa94a526"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07e545e65ccc1764fb5e1af899f8f13f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::put_code" ref="a07e545e65ccc1764fb5e1af899f8f13f" args="(object x)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>put_code</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96bc71df82b8fb85bb3550a0207dd39e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::regexString" ref="a96bc71df82b8fb85bb3550a0207dd39e" args="(string inData, string inPattern, string presep, string postsep)" -->
static string&nbsp;</td><td class="memItemRight" valign="bottom"><b>regexString</b> (string inData, string inPattern, string presep, string postsep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#afad050821403aceffef30ade33ac7674">repeat</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator (which you can use in a for-in loop) which repeats indefinitely. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.  <a href="#afad050821403aceffef30ade33ac7674"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07aacd671c465d30285599f23444b73"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::retract" ref="af07aacd671c465d30285599f23444b73" args="(object Term)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>retract</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a692047d436d00e007c6a0ec3d4eaa9d8">retractall</a> (object Head)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retract all dynamic clauses which unify with Head. If this matches all clauses in a predicate, the predicate is still defined. To completely remove the predicate, see abolish.  <a href="#a692047d436d00e007c6a0ec3d4eaa9d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a4328dafb342ea434dfc1be947635bb9e">retractFact</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, object[] arguments)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is deprecated for backward compatibility. You should use retractall.  <a href="#a4328dafb342ea434dfc1be947635bb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a530c82ad86f6ba830fe37cf58a66c1b5">round</a> (object x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ISO standard returns an int.  <a href="#a530c82ad86f6ba830fe37cf58a66c1b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a62c71c835fb4003aa1dd0a0ab4c08bec">script_event</a> (object script_event, object script_params)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">script_event calls hosting script with events as a callback method.  <a href="#a62c71c835fb4003aa1dd0a0ab4c08bec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#acf52de35452b8ea540bac147a899738f">see</a> (object input)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If input is a TextReader, use it. If input is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or String, create a StreamReader with the input as the filename. If input is a Prolog list, then read character codes from it.  <a href="#acf52de35452b8ea540bac147a899738f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc70ca35fe9e3782dd934990641cef03"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::seen" ref="acc70ca35fe9e3782dd934990641cef03" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>seen</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd95aa09d57c95a59a3bbd01c51dd31"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::set_prolog_flag" ref="a6bd95aa09d57c95a59a3bbd01c51dd31" args="(object Key, object Value)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_prolog_flag</b> (object Key, object Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56cfc5d48aed637632cc1834be4c8978"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sign" ref="a56cfc5d48aed637632cc1834be4c8978" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>sign</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96468840585ea358e0aff7ce26de27c9"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sin" ref="a96468840585ea358e0aff7ce26de27c9" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>sin</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a2153668e22eb4598e99978ae7b7bec29">sort</a> (object List, object Sorted)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort List according to termLessThan, remove duplicates and unify with Sorted.  <a href="#a2153668e22eb4598e99978ae7b7bec29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7388320cfdfc38b8bdcb0c71a245fa9c">sortArray</a> (List&lt; object &gt; array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the array in place according to termLessThan. This does not remove duplicates.  <a href="#a7388320cfdfc38b8bdcb0c71a245fa9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a6fdbea69d3bc79f66c858e60a6a0fe29">sortArray</a> (object[] array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the array in place according to termLessThan. This does not remove duplicates.  <a href="#a6fdbea69d3bc79f66c858e60a6a0fe29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5805ebaecfc0194c4552921760aa058f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sqrt" ref="a5805ebaecfc0194c4552921760aa058f" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4018b3cf7119385815311aff6fa157"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sub_atom" ref="abf4018b3cf7119385815311aff6fa157" args="(object atom, object Before, object Length, object After, object Sub_atom)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>sub_atom</b> (object atom, object Before, object Length, object After, object Sub_atom)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae122764d57e302ac932a5860b6636642"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::subtract" ref="ae122764d57e302ac932a5860b6636642" args="(object x, object y)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (object x, object y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#ab5fc71d8d64249c2e2f22d6bf19289b9">succeed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator (which you can use in a for-in loop) which does one iteration. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.  <a href="#ab5fc71d8d64249c2e2f22d6bf19289b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#abd9da5a1a18b6e31284aa521b30b9273">tell</a> (object output)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If output is a TextWriter, use it. If output is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or a String, create a StreamWriter with the input as the filename.  <a href="#abd9da5a1a18b6e31284aa521b30b9273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a6a6d9a17bd0810476a20e8c7798a49"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termEqual" ref="a9a6a6d9a17bd0810476a20e8c7798a49" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termEqual</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab460b416761c4b969ede54da8a5e6fd1"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termGreaterThan" ref="ab460b416761c4b969ede54da8a5e6fd1" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termGreaterThan</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f047a106589e10cbfb098d70d6156da"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termGreaterThanOrEqual" ref="a3f047a106589e10cbfb098d70d6156da" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termGreaterThanOrEqual</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44cd08a4d0078f03c73831f379630c1b"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termLessThan" ref="a44cd08a4d0078f03c73831f379630c1b" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termLessThan</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ecd24a9a0a0e56df5faff1464fdc6c5"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termLessThanOrEqual" ref="a5ecd24a9a0a0e56df5faff1464fdc6c5" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termLessThanOrEqual</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad225795cba06b19c254b4fdcb18ca2e2"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::termNotEqual" ref="ad225795cba06b19c254b4fdcb18ca2e2" args="(object Term1, object Term2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>termNotEqual</b> (object Term1, object Term2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7829c0455954bd35487b78668c4f77f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::throwException" ref="af7829c0455954bd35487b78668c4f77f" args="(object Term)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>throwException</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2108d62323e5259fad41062fdb62f330"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::toFloat" ref="a2108d62323e5259fad41062fdb62f330" args="(object x)" -->
static object&nbsp;</td><td class="memItemRight" valign="bottom"><b>toFloat</b> (object x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c5fd1cb1db90b4f9ea583b324cd769"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::told" ref="a58c5fd1cb1db90b4f9ea583b324cd769" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>told</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a3b1bf14991c97d5de874f0a458fa621b">truncate</a> (object x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ISO standard returns an int.  <a href="#a3b1bf14991c97d5de874f0a458fa621b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aad2ab6a90418c116b00f5c867efacf54">unify</a> (object arg1, object arg2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If arg1 or arg2 is an object with a unify method (such as <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a> or <a class="el" href="../../d8/df7/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Functor.html">Functor</a>) then just call its unify with the other argument. The object's unify method will bind the values or check for equals as needed. Otherwise, both arguments are "normal" (atomic) values so if they are equal then succeed (yield once), else fail (don't yield). For more details, see <a href="http://yieldprolog.sourceforge.net/tutorial1.html.">http://yieldprolog.sourceforge.net/tutorial1.html.</a>  <a href="#aad2ab6a90418c116b00f5c867efacf54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a44008337db86ea9633d90c023b242be9">unifyArrays</a> (object[] array1, object[] array2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aad2ab6a90418c116b00f5c867efacf54" title="If arg1 or arg2 is an object with a unify method (such as Variable or Functor) then just call its uni...">YP.unify</a> to unify each of the elements of the two arrays, and yield once if they all unify.  <a href="#a44008337db86ea9633d90c023b242be9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8712365ad97287118166860850f3b264"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::univ" ref="a8712365ad97287118166860850f3b264" args="(object Term, object List)" -->
static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>univ</b> (object Term, object List)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static IEnumerable&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a6c98742131aa7d2f4660423c044f5c21">unknownPredicate</a> (<a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> name, int arity, string message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If _prologFlags["unknown"] is fail then return <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b10a4bda0c5ac54f24ef7d1d7cfff1e" title="Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.">fail()</a>, else if _prologFlags["unknown"] is warning then write the message to YP.write and return <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b10a4bda0c5ac54f24ef7d1d7cfff1e" title="Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.">fail()</a>, else throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for existence_error. .  <a href="#a6c98742131aa7d2f4660423c044f5c21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa67f656082c25a0e95ed15e6a511b416"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::var" ref="aa67f656082c25a0e95ed15e6a511b416" args="(object Term)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>var</b> (object Term)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dfbada3dd8b480f66a8a4519642e0ba"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::write" ref="a4dfbada3dd8b480f66a8a4519642e0ba" args="(object x)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>write</b> (object x)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a672427c096cf527d9422770469e95d14"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::MAX_ARITY" ref="a672427c096cf527d9422770469e95d14" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>MAX_ARITY</b> = 255</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html" title="YP has static methods for general functions in Yield Prolog such as getValue and unify.">YP</a> has static methods for general functions in Yield Prolog such as <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a63d52c4648e934ca25ae4d2ff08daafd" title="If value is a Variable, then return its getValue. Otherwise, just return value. You should call YP...">getValue</a> and <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aad2ab6a90418c116b00f5c867efacf54" title="If arg1 or arg2 is an object with a unify method (such as Variable or Functor) then just call its uni...">unify</a>. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0e5e5164736244adc482d6f7cba5d854"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::assertFact" ref="a0e5e5164736244adc482d6f7cba5d854" args="(Atom name, object[] values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.assertFact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert values at the end of the set of facts for the predicate with the name and with arity values.Length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>must be an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>the array of arguments to the fact predicate. It is an error if an value has an unbound variable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a493bd708486bead5e6e911ac74d21711"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::ceiling" ref="a493bd708486bead5e6e911ac74d21711" args="(object x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.ceiling </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ISO standard returns an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a955a2808f403700c18949347b96a47c4"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::convertDouble" ref="a955a2808f403700c18949347b96a47c4" args="(object term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.convertDouble </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert term to a double. This may convert an int to a double, etc. If term is a single-element List, use its first element (to handle the char types like "a"). If can't convert, throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for type_error evaluable (because this is only called from arithmetic functions). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>term</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a34dbcfa4d9b3a2c2e2656eea4bc4029b"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::convertInt" ref="a34dbcfa4d9b3a2c2e2656eea4bc4029b" args="(object term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.convertInt </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert term to an int. If term is a single-element List, use its first element (to handle the char types like "a"). If can't convert, throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for type_error evaluable (because this is only called from arithmetic functions). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>term</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5a14bf30491d3a19163f4316dce97a09"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::current_predicate" ref="a5a14bf30491d3a19163f4316dce97a09" args="(object NameSlashArity, Type declaringClass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.current_predicate </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>NameSlashArity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>declaringClass</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If NameSlashArity is var, match with all the dynamic predicates using the Name/Artity form. If NameSlashArity is not var, check if the Name/Arity exists as a static or dynamic predicate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NameSlashArity</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>declaringClass</em>&nbsp;</td><td>if not null, used to resolve references to the default module <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html#a59e1c13a8520efe54c916a49f6d7611a" title="Return the unique Atom object for name where module is null. You should use this to create an Atom in...">Atom.a</a>("")</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a740a42f3afe3de9b542675383ce5fa45"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::divide" ref="a740a42f3afe3de9b542675383ce5fa45" args="(object x, object y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.divide </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return floating point, even if both arguments are integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7b10a4bda0c5ac54f24ef7d1d7cfff1e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::fail" ref="a7b10a4bda0c5ac54f24ef7d1d7cfff1e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.fail </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a61ac4eab31119bd86446e25a8bf29fed"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::floor" ref="a61ac4eab31119bd86446e25a8bf29fed" args="(object x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.floor </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ISO standard returns an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad1f1d01cb281a94e5fc2eb71e49361a0"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::getFunctorArgs" ref="ad1f1d01cb281a94e5fc2eb71e49361a0" args="(object term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object [] OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.getFunctorArgs </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If term is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or functor type, return an array of its args. Otherwise, return an empty array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>term</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab205a11341384ec7c664d709e953aa6a"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::getFunctorName" ref="ab205a11341384ec7c664d709e953aa6a" args="(object term)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.getFunctorName </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>term</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If term is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or functor type, return its name. Otherwise, return term. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>term</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afdb903ff06bf425a64689fa8b30c1818"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::getInt" ref="afdb903ff06bf425a64689fa8b30c1818" args="(object term, out int intTerm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.getInt </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&nbsp;</td>
          <td class="paramname"> <em>intTerm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If term is an integer, set intTerm. If term is a single-element List, use its first element (to handle the char types like "a"). Return true for success, false if can't convert. We use a success return value because throwing an exception is inefficient. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>term</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa190a338167f3bb8f7f06ab26a9ff3cd"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::getIterator" ref="aa190a338167f3bb8f7f06ab26a9ff3cd" args="(object Goal, Type declaringClass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.getIterator </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>Goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>declaringClass</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If Goal is a simple predicate, call YP.getFunctorName(Goal) using arguments from YP.getFunctorArgs(Goal). If not found, this throws a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for existence_error. Otherwise, compile the goal as a single clause predicate and invoke it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Goal</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>declaringClass</em>&nbsp;</td><td>if not null, used to resolve references to the default module <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html#a59e1c13a8520efe54c916a49f6d7611a" title="Return the unique Atom object for name where module is null. You should use this to create an Atom in...">Atom.a</a>("")</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a63d52c4648e934ca25ae4d2ff08daafd"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::getValue" ref="a63d52c4648e934ca25ae4d2ff08daafd" args="(object value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.getValue </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If value is a <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a>, then return its getValue. Otherwise, just return value. You should call <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a63d52c4648e934ca25ae4d2ff08daafd" title="If value is a Variable, then return its getValue. Otherwise, just return value. You should call YP...">YP.getValue</a> on any object that may be a <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a> to get the value to pass to other functions in your system that are not part of Yield Prolog, such as math functions or file I/O. For more details, see <a href="http://yieldprolog.sourceforge.net/tutorial1.html.">http://yieldprolog.sourceforge.net/tutorial1.html.</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a651e941b5fb0c2c673c1a1825986d4ab"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::isDynamicCurrentPredicate" ref="a651e941b5fb0c2c673c1a1825986d4ab" args="(Atom name, int arity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.isDynamicCurrentPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the dynamic predicate store has an entry for the predicate with name and arity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arity</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af9822d343412e2ee20d27643769c4fd5"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::matchDynamic" ref="af9822d343412e2ee20d27643769c4fd5" args="(Atom name, object[] arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.matchDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>arguments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Match all clauses of the dynamic predicate with the name and with arity arguments.Length. If the predicate is not defined, return the result of <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a6c98742131aa7d2f4660423c044f5c21" title="If _prologFlags[&quot;unknown&quot;] is fail then return fail(), else if _prologFlags[&quot;unknown&q...">YP.unknownPredicate</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>must be an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arguments</em>&nbsp;</td><td>an array of arity number of arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator which you can use in foreach</dd></dl>

</div>
</div>
<a class="anchor" id="a7b476c556d99d02de9b5f6bf80e68367"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::matchFact" ref="a7b476c556d99d02de9b5f6bf80e68367" args="(Atom name, object[] arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.matchFact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>arguments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is deprecated and just calls matchDynamic. This matches all clauses, not just the ones defined with assertFact. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arguments</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6d32f52e75d5d5f3b9c2f77ffa94a526"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::prependFact" ref="a6d32f52e75d5d5f3b9c2f77ffa94a526" args="(Atom name, object[] values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.prependFact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assert values, prepending to the front of the set of facts for the predicate with the name and with arity values.Length. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>must be an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>the array of arguments to the fact predicate. It is an error if an value has an unbound variable.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afad050821403aceffef30ade33ac7674"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::repeat" ref="afad050821403aceffef30ade33ac7674" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.repeat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an iterator (which you can use in a for-in loop) which repeats indefinitely. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a692047d436d00e007c6a0ec3d4eaa9d8"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::retractall" ref="a692047d436d00e007c6a0ec3d4eaa9d8" args="(object Head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.retractall </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>Head</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retract all dynamic clauses which unify with Head. If this matches all clauses in a predicate, the predicate is still defined. To completely remove the predicate, see abolish. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Head</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4328dafb342ea434dfc1be947635bb9e"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::retractFact" ref="a4328dafb342ea434dfc1be947635bb9e" args="(Atom name, object[] arguments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.retractFact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>arguments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is deprecated for backward compatibility. You should use retractall. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>must be an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arguments</em>&nbsp;</td><td>an array of arity number of arguments</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a530c82ad86f6ba830fe37cf58a66c1b5"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::round" ref="a530c82ad86f6ba830fe37cf58a66c1b5" args="(object x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.round </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ISO standard returns an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a62c71c835fb4003aa1dd0a0ab4c08bec"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::script_event" ref="a62c71c835fb4003aa1dd0a0ab4c08bec" args="(object script_event, object script_params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.script_event </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>script_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>script_params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>script_event calls hosting script with events as a callback method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>script_event</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>script_params</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acf52de35452b8ea540bac147a899738f"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::see" ref="acf52de35452b8ea540bac147a899738f" args="(object input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.see </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>input</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If input is a TextReader, use it. If input is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or String, create a StreamReader with the input as the filename. If input is a Prolog list, then read character codes from it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2153668e22eb4598e99978ae7b7bec29"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sort" ref="a2153668e22eb4598e99978ae7b7bec29" args="(object List, object Sorted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.sort </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>List</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>Sorted</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort List according to termLessThan, remove duplicates and unify with Sorted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>List</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Sorted</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7388320cfdfc38b8bdcb0c71a245fa9c"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sortArray" ref="a7388320cfdfc38b8bdcb0c71a245fa9c" args="(List&lt; object &gt; array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.sortArray </td>
          <td>(</td>
          <td class="paramtype">List&lt; object &gt;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the array in place according to termLessThan. This does not remove duplicates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fdbea69d3bc79f66c858e60a6a0fe29"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::sortArray" ref="a6fdbea69d3bc79f66c858e60a6a0fe29" args="(object[] array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.sortArray </td>
          <td>(</td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the array in place according to termLessThan. This does not remove duplicates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5fc71d8d64249c2e2f22d6bf19289b9"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::succeed" ref="ab5fc71d8d64249c2e2f22d6bf19289b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.succeed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an iterator (which you can use in a for-in loop) which does one iteration. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abd9da5a1a18b6e31284aa521b30b9273"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::tell" ref="abd9da5a1a18b6e31284aa521b30b9273" args="(object output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.tell </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>output</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If output is a TextWriter, use it. If output is an <a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a> or a String, create a StreamWriter with the input as the filename. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b1bf14991c97d5de874f0a458fa621b"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::truncate" ref="a3b1bf14991c97d5de874f0a458fa621b" args="(object x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static object OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.truncate </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ISO standard returns an int. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aad2ab6a90418c116b00f5c867efacf54"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::unify" ref="aad2ab6a90418c116b00f5c867efacf54" args="(object arg1, object arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.unify </td>
          <td>(</td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If arg1 or arg2 is an object with a unify method (such as <a class="el" href="../../dd/df5/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Variable.html" title="A Variable is passed to a function so that it can be unified with value or another Variable...">Variable</a> or <a class="el" href="../../d8/df7/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Functor.html">Functor</a>) then just call its unify with the other argument. The object's unify method will bind the values or check for equals as needed. Otherwise, both arguments are "normal" (atomic) values so if they are equal then succeed (yield once), else fail (don't yield). For more details, see <a href="http://yieldprolog.sourceforge.net/tutorial1.html.">http://yieldprolog.sourceforge.net/tutorial1.html.</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg1</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg2</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a44008337db86ea9633d90c023b242be9"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::unifyArrays" ref="a44008337db86ea9633d90c023b242be9" args="(object[] array1, object[] array2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.unifyArrays </td>
          <td>(</td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object[]&nbsp;</td>
          <td class="paramname"> <em>array2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#aad2ab6a90418c116b00f5c867efacf54" title="If arg1 or arg2 is an object with a unify method (such as Variable or Functor) then just call its uni...">YP.unify</a> to unify each of the elements of the two arrays, and yield once if they all unify. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array1</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>array2</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6c98742131aa7d2f4660423c044f5c21"></a><!-- doxytag: member="OpenSim::Region::ScriptEngine::Shared::YieldProlog::YP::unknownPredicate" ref="a6c98742131aa7d2f4660423c044f5c21" args="(Atom name, int arity, string message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static IEnumerable&lt;bool&gt; OpenSim.Region.ScriptEngine.Shared.YieldProlog.YP.unknownPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d66/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1Atom.html">Atom</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If _prologFlags["unknown"] is fail then return <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b10a4bda0c5ac54f24ef7d1d7cfff1e" title="Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.">fail()</a>, else if _prologFlags["unknown"] is warning then write the message to YP.write and return <a class="el" href="../../d7/d12/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1YP.html#a7b10a4bda0c5ac54f24ef7d1d7cfff1e" title="Return an iterator (which you can use in a for-in loop) which does zero iterations. This returns a pre-existing iterator which is more efficient than letting the compiler generate a new one.">fail()</a>, else throw a <a class="el" href="../../db/de2/classOpenSim_1_1Region_1_1ScriptEngine_1_1Shared_1_1YieldProlog_1_1PrologException.html" title="A PrologException is used as the exception thrown by YP.throw(Term).">PrologException</a> for existence_error. . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arity</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>addon-modules/YieldProlog/Modules/YP.cs</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
